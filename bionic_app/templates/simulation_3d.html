{% extends 'base.html' %}
{% load static %}

{% block title %}3D Simulation - Bionic Hand System{% endblock %}

{% block extra_css %}
<style>
    .simulation-container {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 30px;
    }
    
    #canvas3d {
        width: 100%;
        height: 500px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 10px;
        cursor: grab;
    }
    
    #canvas3d:active {
        cursor: grabbing;
    }
    
    .mode-selector {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        justify-content: center;
        margin-top: 20px;
    }
    
    .mode-btn {
        padding: 12px 24px;
        border: none;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s;
        color: white;
    }
    
    .mode-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }
    
    .mode-btn.active {
        box-shadow: 0 0 20px rgba(255,255,255,0.5);
    }
    
    /* Hand Animation Styles */
    .hand-animation {
        width: 300px;
        height: 300px;
        margin: 20px auto;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .hand-svg {
        width: 100%;
        height: 100%;
        filter: drop-shadow(0 5px 15px rgba(0,0,0,0.3));
    }
    
    /* Finger animations */
    .finger {
        transform-origin: bottom center;
        transition: transform 0.5s ease;
    }
    
    .finger.curl {
        transform: rotate(-45deg);
    }
    
    .finger.extend {
        transform: rotate(0deg);
    }
    
    /* Status display */
    .status-display {
        background: white;
        color: #333;
        padding: 15px;
        border-radius: 10px;
        text-align: center;
        margin-top: 20px;
    }
    
    .status-display h4 {
        margin: 0;
        color: #667eea;
    }
    
    /* Info cards */
    .info-card {
        background: rgba(255, 255, 255, 0.95);
        border-radius: 10px;
        padding: 20px;
        margin-bottom: 20px;
    }
    
    .feature-badge {
        display: inline-block;
        padding: 5px 15px;
        background: #667eea;
        color: white;
        border-radius: 20px;
        font-size: 0.9rem;
        margin: 5px;
    }
</style>
{% endblock %}

{% block content %}
<div class="container my-5">
    <h1 class="fw-bold mb-2 text-center">3D Interactive Bionic Hand</h1>
    <p class="text-center text-muted mb-4">Rotate, zoom, and control the 3D hand model</p>
    
    <!-- 3D Model Section -->
    <div class="simulation-container">
        <div id="canvas3d"></div>
        
        <div class="mode-selector">
            <button class="mode-btn active" style="background: #28a745;" onclick="setHandMode('open')">
                <i class="bi bi-hand-index"></i> Open Hand
            </button>
            <button class="mode-btn" style="background: #dc3545;" onclick="setHandMode('closed')">
                <i class="bi bi-hand-thumbs-up"></i> Close Hand
            </button>
            <button class="mode-btn" style="background: #ffc107;" onclick="setHandMode('grip')">
                <i class="bi bi-grip-horizontal"></i> Grip Mode
            </button>
            <button class="mode-btn" style="background: #17a2b8;" onclick="setHandMode('pinch')">
                <i class="bi bi-hand-index-thumb-fill"></i> Pinch Grip
            </button>
            <button class="mode-btn" style="background: #6c757d;" onclick="setHandMode('point')">
                <i class="bi bi-hand-index-fill"></i> Point Mode
            </button>
        </div>
        
        <div class="status-display">
            <h4 id="currentMode">Open Hand</h4>
            <p class="mb-0 text-muted" id="modeDescription">All fingers extended</p>
        </div>
    </div>
    
    <!-- 2D Animation Fallback -->
    <div class="card mb-4">
        <div class="card-header bg-primary text-white">
            <h5 class="mb-0"><i class="bi bi-play-circle"></i> 2D Hand Animation</h5>
        </div>
        <div class="card-body text-center">
            <div class="hand-animation">
                <svg class="hand-svg" viewBox="0 0 200 300" id="handSvg">
                    <!-- Palm -->
                    <rect x="60" y="150" width="80" height="120" fill="#FFD1A4" stroke="#333" stroke-width="2" rx="10"/>
                    
                    <!-- Thumb -->
                    <g class="finger" id="thumb">
                        <rect x="30" y="180" width="35" height="60" fill="#FFD1A4" stroke="#333" stroke-width="2" rx="8"/>
                    </g>
                    
                    <!-- Index Finger -->
                    <g class="finger" id="index">
                        <rect x="65" y="80" width="25" height="75" fill="#FFD1A4" stroke="#333" stroke-width="2" rx="8"/>
                    </g>
                    
                    <!-- Middle Finger -->
                    <g class="finger" id="middle">
                        <rect x="95" y="60" width="25" height="95" fill="#FFD1A4" stroke="#333" stroke-width="2" rx="8"/>
                    </g>
                    
                    <!-- Ring Finger -->
                    <g class="finger" id="ring">
                        <rect x="125" y="80" width="25" height="75" fill="#FFD1A4" stroke="#333" stroke-width="2" rx="8"/>
                    </g>
                    
                    <!-- Pinky -->
                    <g class="finger" id="pinky">
                        <rect x="155" y="100" width="20" height="55" fill="#FFD1A4" stroke="#333" stroke-width="2" rx="8"/>
                    </g>
                </svg>
            </div>
            
            <div class="btn-group" role="group">
                <button class="btn btn-outline-primary" onclick="animate2DMode('open')">Open</button>
                <button class="btn btn-outline-primary" onclick="animate2DMode('closed')">Close</button>
                <button class="btn btn-outline-primary" onclick="animate2DMode('grip')">Grip</button>
                <button class="btn btn-outline-primary" onclick="animate2DMode('point')">Point</button>
            </div>
        </div>
    </div>
    
    <!-- Features Info -->
    <div class="row">
        <div class="col-md-6">
            <div class="info-card">
                <h5><i class="bi bi-box text-primary"></i> 3D Model Features</h5>
                <div class="mt-3">
                    <span class="feature-badge">Rotate 360Â°</span>
                    <span class="feature-badge">Zoom In/Out</span>
                    <span class="feature-badge">5 Hand Modes</span>
                    <span class="feature-badge">Smooth Transitions</span>
                </div>
                <p class="mt-3 mb-0 text-muted">
                    <small>Click and drag to rotate â€¢ Scroll to zoom â€¢ Click buttons to change modes</small>
                </p>
            </div>
        </div>
        <div class="col-md-6">
            <div class="info-card">
                <h5><i class="bi bi-play-circle text-success"></i> Animation Features</h5>
                <div class="mt-3">
                    <span class="feature-badge">Smooth Animations</span>
                    <span class="feature-badge">Finger Control</span>
                    <span class="feature-badge">Multiple Modes</span>
                    <span class="feature-badge">Lightweight</span>
                </div>
                <p class="mt-3 mb-0 text-muted">
                    <small>2D fallback for devices that don't support 3D rendering</small>
                </p>
            </div>
        </div>
    </div>
    
    <!-- Simulation Logs -->
    <div class="card mt-4">
        <div class="card-header bg-dark text-white">
            <h5 class="mb-0"><i class="bi bi-list-ul"></i> Simulation Logs</h5>
        </div>
        <div class="card-body">
            <div id="logContainer">
                <p class="text-muted">Simulation logs will appear here...</p>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<!-- Three.js CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>

<script>
    // 3D Hand Model Setup
    let scene, camera, renderer, hand, controls;
    let currentHandMode = 'open';
    
    function init3D() {
        // Create scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x667eea);
        scene.fog = new THREE.Fog(0x667eea, 5, 15);
        
        // Create camera
        camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
        camera.position.set(0, 1, 5);
        camera.lookAt(0, 0, 0);
        
        // Create renderer
        const canvas = document.getElementById('canvas3d');
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        canvas.appendChild(renderer.domElement);
        
        // Add better lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(5, 8, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        scene.add(directionalLight);
        
        const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
        fillLight.position.set(-5, 3, -5);
        scene.add(fillLight);
        
        const backLight = new THREE.PointLight(0xffffff, 0.5);
        backLight.position.set(0, 3, -5);
        scene.add(backLight);
        
        // Try to load GLB model first, fallback to geometric hand
        loadHandModel();
        
        // Orbit Controls for better interaction
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.08;
        controls.minDistance = 2;
        controls.maxDistance = 10;
        controls.target.set(0, 0, 0);
        controls.update();
        
        // Animation loop
        animate3D();
    }
    
    function loadHandModel() {
        // Check if GLTFLoader is available
        if (typeof THREE.GLTFLoader === 'undefined') {
            console.warn('âš ï¸ GLTFLoader not available, using geometric hand');
            hand = createHandModel();
            scene.add(hand);
            logHandStructure();
            return;
        }
        
        const loader = new THREE.GLTFLoader();
        const modelPath = "{% static 'models/hand.glb' %}";
        
        // Try loading GLB model
        loader.load(
            modelPath,
            function(gltf) {
                // Success - GLB model loaded
                hand = gltf.scene;
                hand.scale.set(1, 1, 1);
                scene.add(hand);
                
                console.log('âœ… GLB Hand Model Loaded Successfully!');
                logHandStructure();
            },
            function(xhr) {
                const percent = (xhr.loaded / xhr.total * 100).toFixed(0);
                console.log(`Loading GLB model: ${percent}%`);
            },
            function(error) {
                // Fallback to geometric hand
                console.warn('âš ï¸ GLB model not found, creating realistic geometric hand');
                hand = createHandModel();
                scene.add(hand);
                logHandStructure();
            }
        );
    }
    
    function logHandStructure() {
        if (!hand) {
            console.warn('Hand model not loaded yet');
            return;
        }
        
        console.log('ðŸ” Traversing hand model structure:');
        console.log('==========================================');
        
        hand.traverse((child) => {
            const name = child.name || 'unnamed';
            console.log(name);
            
            // Identify finger joints for animation
            if (child.isBone || 
                (child.name && (
                    child.name.toLowerCase().includes("finger") || 
                    child.name.toLowerCase().includes("joint") ||
                    child.name.toLowerCase().includes("thumb") ||
                    child.name.toLowerCase().includes("index") ||
                    child.name.toLowerCase().includes("middle") ||
                    child.name.toLowerCase().includes("ring") ||
                    child.name.toLowerCase().includes("pinky") ||
                    child.name.toLowerCase().includes("segment")
                ))) {
                console.log('  â†³ ðŸŽ¯ Animatable part:', child.name);
            }
        });
        
        console.log('==========================================');
        console.log('âœ… Model has', hand.children.length, 'top-level children');
    }
    
    function createHandModel() {
        const handGroup = new THREE.Group();
        handGroup.name = 'Bionic_Hand';
        
        // Enhanced skin material with subsurface scattering effect
        const skinMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xFFCBA4,
            shininess: 12,
            specular: 0x444444,
            emissive: 0x221100,
            emissiveIntensity: 0.05
        });
        
        // Darker material for joints
        const jointMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xFFB894,
            shininess: 8,
            specular: 0x333333
        });
        
        // Palm - more anatomically correct
        const palmGeometry = new THREE.BoxGeometry(2.0, 2.6, 0.8);
        const palm = new THREE.Mesh(palmGeometry, skinMaterial);
        palm.name = 'Palm';
        palm.position.y = 0;
        palm.castShadow = true;
        palm.receiveShadow = true;
        handGroup.add(palm);
        
        // Wrist
        const wristGeometry = new THREE.CylinderGeometry(0.7, 0.8, 1.0, 20);
        const wrist = new THREE.Mesh(wristGeometry, skinMaterial);
        wrist.name = 'Wrist';
        wrist.position.y = -1.8;
        wrist.castShadow = true;
        wrist.receiveShadow = true;
        handGroup.add(wrist);
        
        // Realistic finger configurations
        const fingerConfigs = [
            { name: 'thumb', x: -1.1, y: 0.5, z: 0.4, length: 1.3, segments: 2, angle: 0.5, baseRadius: 0.16 },
            { name: 'index', x: -0.65, y: 1.5, z: 0, length: 1.7, segments: 3, angle: 0.08, baseRadius: 0.15 },
            { name: 'middle', x: -0.2, y: 1.6, z: 0, length: 1.9, segments: 3, angle: 0, baseRadius: 0.15 },
            { name: 'ring', x: 0.25, y: 1.5, z: 0, length: 1.7, segments: 3, angle: -0.06, baseRadius: 0.14 },
            { name: 'pinky', x: 0.7, y: 1.3, z: 0, length: 1.4, segments: 3, angle: -0.12, baseRadius: 0.12 }
        ];
        
        fingerConfigs.forEach((config) => {
            const fingerGroup = new THREE.Group();
            fingerGroup.name = config.name;
            fingerGroup.position.set(config.x, config.y, config.z);
            fingerGroup.rotation.z = config.angle;
            
            let currentY = 0;
            
            // Create finger segments with proper hierarchy
            for (let i = 0; i < config.segments; i++) {
                const segmentLength = config.length / config.segments;
                const radius = config.baseRadius - (i * 0.03); // Progressive taper
                
                // Segment group for proper rotation pivot
                const segmentGroup = new THREE.Group();
                segmentGroup.position.y = currentY;
                segmentGroup.name = `${config.name}_segment${i}`;
                
                // Phalanx (finger bone) - cylinder
                const phalanxGeometry = new THREE.CylinderGeometry(
                    radius, radius * 0.88, segmentLength, 20
                );
                const phalanx = new THREE.Mesh(phalanxGeometry, skinMaterial);
                phalanx.position.y = segmentLength / 2;
                phalanx.castShadow = true;
                phalanx.receiveShadow = true;
                phalanx.name = `${config.name}_phalanx${i}`;
                segmentGroup.add(phalanx);
                
                // Joint sphere at base
                const jointGeometry = new THREE.SphereGeometry(radius * 1.15, 16, 16);
                const joint = new THREE.Mesh(jointGeometry, jointMaterial);
                joint.castShadow = true;
                joint.receiveShadow = true;
                joint.name = `${config.name}_joint${i}`;
                segmentGroup.add(joint);
                
                // Fingertip on last segment
                if (i === config.segments - 1) {
                    // Rounded fingertip
                    const tipGeometry = new THREE.SphereGeometry(radius * 0.95, 20, 20);
                    const tip = new THREE.Mesh(tipGeometry, skinMaterial);
                    tip.position.y = segmentLength;
                    tip.castShadow = true;
                    tip.name = `${config.name}_tip`;
                    phalanx.add(tip);
                    
                    // Fingernail
                    const nailGeometry = new THREE.CircleGeometry(radius * 0.75, 20);
                    const nailMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0xFFE5D0,
                        shininess: 40,
                        specular: 0x666666
                    });
                    const nail = new THREE.Mesh(nailGeometry, nailMaterial);
                    nail.position.set(0, segmentLength * 0.75, radius * 0.92);
                    nail.rotation.x = -0.25;
                    nail.name = `${config.name}_nail`;
                    phalanx.add(nail);
                    
                    // Fingerprint detail (subtle)
                    const printGeometry = new THREE.CircleGeometry(radius * 0.85, 20);
                    const printMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0xFFB894,
                        shininess: 5
                    });
                    const print = new THREE.Mesh(printGeometry, printMaterial);
                    print.position.set(0, segmentLength * 0.75, -radius * 0.92);
                    print.rotation.x = 0.25;
                    print.name = `${config.name}_print`;
                    phalanx.add(print);
                }
                
                fingerGroup.add(segmentGroup);
                currentY += segmentLength;
            }
            
            handGroup.add(fingerGroup);
        });
        
        // Add subtle ground shadow plane
        const shadowGeometry = new THREE.PlaneGeometry(8, 8);
        const shadowMaterial = new THREE.ShadowMaterial({ opacity: 0.25 });
        const shadowPlane = new THREE.Mesh(shadowGeometry, shadowMaterial);
        shadowPlane.rotation.x = -Math.PI / 2;
        shadowPlane.position.y = -3;
        shadowPlane.receiveShadow = true;
        shadowPlane.name = 'ShadowPlane';
        scene.add(shadowPlane);
        
        return handGroup;
    }
    
    function animate3D() {
        requestAnimationFrame(animate3D);
        
        // Update controls if they exist
        if (controls) {
            controls.update();
        }
        
        // Subtle idle animation - hand slightly rotates when open
        if (hand && currentHandMode === 'open') {
            hand.rotation.y += 0.002;
        }
        
        renderer.render(scene, camera);
    }
    
    function setHandMode(mode) {
        currentHandMode = mode;
        
        // Update button states
        document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
        event.target.classList.add('active');
        
        // Update status
        const modeInfo = {
            'open': { title: 'Open Hand', desc: 'All fingers extended' },
            'closed': { title: 'Closed Fist', desc: 'All fingers curled' },
            'grip': { title: 'Grip Mode', desc: 'Power grip position' },
            'pinch': { title: 'Pinch Grip', desc: 'Thumb and index finger' },
            'point': { title: 'Point Mode', desc: 'Index finger extended' }
        };
        
        document.getElementById('currentMode').textContent = modeInfo[mode].title;
        document.getElementById('modeDescription').textContent = modeInfo[mode].desc;
        
        // Animate 3D hand
        animateHandTo(mode);
        
        // Log to Firestore
        logSimulation(modeInfo[mode].title);
    }
    
    function animateHandTo(mode) {
        if (!hand) {
            console.warn('Hand model not loaded yet');
            return;
        }
        
        console.log(`ðŸŽ¬ Animating hand to: ${mode}`);
        
        const fingerNames = ['thumb', 'index', 'middle', 'ring', 'pinky'];
        
        fingerNames.forEach((fingerName, fingerIndex) => {
            const finger = hand.children.find(child => child.name === fingerName);
            if (!finger) {
                console.warn(`Finger not found: ${fingerName}`);
                return;
            }
            
            // Animate each segment of the finger
            finger.children.forEach((segment, segmentIndex) => {
                if (!segment.name || !segment.name.includes('segment')) return;
                
                let targetRotation = 0;
                
                switch(mode) {
                    case 'open':
                        targetRotation = 0;
                        break;
                    case 'closed':
                        // Progressive curl - each segment curls more
                        targetRotation = -0.5 - (segmentIndex * 0.35);
                        break;
                    case 'grip':
                        if (fingerName === 'thumb') {
                            targetRotation = -0.4 - (segmentIndex * 0.25);
                        } else {
                            targetRotation = -0.45 - (segmentIndex * 0.3);
                        }
                        break;
                    case 'pinch':
                        if (fingerName === 'thumb' || fingerName === 'index') {
                            targetRotation = -0.35 - (segmentIndex * 0.2);
                        } else {
                            targetRotation = -0.5 - (segmentIndex * 0.35);
                        }
                        break;
                    case 'point':
                        if (fingerName === 'index') {
                            targetRotation = 0; // Keep extended
                        } else {
                            targetRotation = -0.5 - (segmentIndex * 0.35);
                        }
                        break;
                }
                
                // Smooth animation with easing
                const startRotation = segment.rotation.x;
                const animationDuration = 600; // ms
                const startTime = Date.now();
                
                function animateSegment() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / animationDuration, 1);
                    
                    // Ease out cubic for smooth deceleration
                    const eased = 1 - Math.pow(1 - progress, 3);
                    
                    segment.rotation.x = startRotation + (targetRotation - startRotation) * eased;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateSegment);
                    }
                }
                
                animateSegment();
            });
        });
        
        console.log(`âœ… Animation started for ${mode} mode`);
    }
    
    // 2D Animation Functions
    function animate2DMode(mode) {
        const fingers = ['thumb', 'index', 'middle', 'ring', 'pinky'];
        
        fingers.forEach((fingerId, index) => {
            const finger = document.getElementById(fingerId);
            finger.classList.remove('curl', 'extend');
            
            switch(mode) {
                case 'open':
                    finger.classList.add('extend');
                    break;
                case 'closed':
                    finger.classList.add('curl');
                    break;
                case 'grip':
                    finger.classList.add('curl');
                    break;
                case 'point':
                    if (fingerId === 'index') {
                        finger.classList.add('extend');
                    } else {
                        finger.classList.add('curl');
                    }
                    break;
            }
        });
        
        logSimulation(`2D Animation: ${mode}`);
    }
    
    // Log simulation to Firestore
    function logSimulation(action) {
        const formData = new FormData();
        formData.append('csrfmiddlewaretoken', '{{ csrf_token }}');
        formData.append('action', action);
        
        fetch('{% url "simulation" %}', {
            method: 'POST',
            body: formData,
            headers: {
                'X-Requested-With': 'XMLHttpRequest'
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                const logContainer = document.getElementById('logContainer');
                const logEntry = document.createElement('div');
                logEntry.className = 'alert alert-success';
                logEntry.innerHTML = `<strong>${action}</strong> - ${new Date().toLocaleTimeString()}`;
                logContainer.insertBefore(logEntry, logContainer.firstChild);
            }
        })
        .catch(error => console.error('Error:', error));
    }
    
    // Initialize 3D on page load
    window.addEventListener('load', () => {
        try {
            init3D();
        } catch (error) {
            console.error('3D initialization failed:', error);
            document.getElementById('canvas3d').innerHTML = '<p class="text-white text-center p-5">3D not supported. Use 2D animation below.</p>';
        }
    });
</script>
{% endblock %}
